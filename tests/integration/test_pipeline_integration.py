"""
Integration tests for the full conversion pipeline.

These tests verify that all pipeline components work together correctly
to convert images to OpenSCAD code.
"""

import re
from pathlib import Path

import numpy as np
import pytest
from PIL import Image

from image_to_scad.config import ConversionConfig, ConversionResult
from image_to_scad.converter import Converter
from image_to_scad.pipeline.image_loader import ImageLoader
from image_to_scad.pipeline.depth_analyzer import DepthAnalyzer
from image_to_scad.pipeline.scad_generator import OpenSCADGenerator


class TestPipelineIntegration:
    """Integration tests for the conversion pipeline."""

    @pytest.fixture
    def sample_image_file(self, tmp_path: Path) -> Path:
        """Create a sample image file for testing."""
        image_path = tmp_path / "test_image.png"
        # Create a gradient image
        size = 128
        image = np.zeros((size, size, 3), dtype=np.uint8)
        image[:, :, 0] = np.tile(np.linspace(0, 255, size, dtype=np.uint8), (size, 1))
        image[:, :, 1] = np.tile(
            np.linspace(0, 255, size, dtype=np.uint8).reshape(-1, 1), (1, size)
        )
        image[:, :, 2] = 128
        Image.fromarray(image).save(image_path)
        return image_path

    @pytest.fixture
    def converter(self) -> Converter:
        """Create a Converter instance."""
        return Converter()

    def test_image_to_depth_to_height_pipeline(
        self, sample_image_file: Path, default_config: ConversionConfig
    ):
        """Test that image loading, depth analysis, and height conversion work together."""
        # Load image
        loader = ImageLoader()
        image = loader.load(sample_image_file)

        assert image.ndim == 3
        assert image.shape[2] == 3

        # Create a mock depth map (skip actual AI inference for speed)
        depth_map = np.random.rand(image.shape[0], image.shape[1]).astype(np.float32)

        # Analyze depth
        analyzer = DepthAnalyzer()
        height_data = analyzer.analyze(depth_map, default_config)

        assert height_data.heights.ndim == 2
        assert height_data.width_mm == default_config.model_width
        assert height_data.heights.min() >= default_config.base_thickness

    def test_height_to_scad_pipeline(
        self, sample_height_data, default_config: ConversionConfig
    ):
        """Test that height data generates valid OpenSCAD code."""
        generator = OpenSCADGenerator()
        scad_code = generator.generate(sample_height_data, default_config)

        # Verify OpenSCAD code structure
        assert "// Generated by image-to-scad" in scad_code
        assert "base_thickness" in scad_code
        assert "max_relief_height" in scad_code
        assert "model_width" in scad_code
        assert "height_data" in scad_code
        assert "polyhedron" in scad_code
        assert "relief_surface()" in scad_code

    def test_scad_code_has_correct_parameters(
        self, sample_height_data, default_config: ConversionConfig
    ):
        """Test that generated OpenSCAD code contains correct parameter values."""
        generator = OpenSCADGenerator()
        scad_code = generator.generate(sample_height_data, default_config)

        # Check parameter values in generated code
        assert f"base_thickness = {default_config.base_thickness:.2f}" in scad_code
        assert f"max_relief_height = {default_config.max_height:.2f}" in scad_code

    def test_scad_code_polyhedron_structure(self, sample_height_data, default_config):
        """Test that polyhedron faces have correct winding order."""
        generator = OpenSCADGenerator()
        scad_code = generator.generate(sample_height_data, default_config)

        # Check for CCW face winding (manifold geometry)
        # Bottom face should be [0, 2, 1] not [0, 1, 2]
        assert "[0, 2, 1]" in scad_code  # bottom face CCW
        assert "[3, 4, 5]" in scad_code  # top face CCW

    def test_full_pipeline_with_custom_config(self, sample_image_file: Path, tmp_path: Path):
        """Test full pipeline with custom configuration."""
        custom_config = ConversionConfig(
            base_thickness=3.0,
            max_height=20.0,
            model_width=150.0,
            detail_level=0.5,
            smoothing=False,
            invert_depth=True,
        )

        # Load and process image
        loader = ImageLoader()
        image = loader.load(sample_image_file)

        # Create mock depth map
        depth_map = np.random.rand(image.shape[0], image.shape[1]).astype(np.float32)

        # Analyze with custom config
        analyzer = DepthAnalyzer()
        height_data = analyzer.analyze(depth_map, custom_config)

        # Generate OpenSCAD
        generator = OpenSCADGenerator()
        scad_code = generator.generate(height_data, custom_config)

        # Verify custom parameters in output
        assert f"base_thickness = {custom_config.base_thickness:.2f}" in scad_code
        assert f"max_relief_height = {custom_config.max_height:.2f}" in scad_code
        assert height_data.width_mm == custom_config.model_width

    def test_pipeline_preserves_aspect_ratio(self, tmp_path: Path):
        """Test that pipeline preserves image aspect ratio."""
        # Create a non-square image
        image_path = tmp_path / "wide_image.png"
        image = np.zeros((100, 200, 3), dtype=np.uint8)  # 2:1 aspect ratio
        image[:, :, 0] = 128
        Image.fromarray(image).save(image_path)

        config = ConversionConfig(model_width=100.0)

        loader = ImageLoader()
        image = loader.load(image_path)

        # Create mock depth map with same dimensions
        depth_map = np.random.rand(image.shape[0], image.shape[1]).astype(np.float32)

        analyzer = DepthAnalyzer()
        height_data = analyzer.analyze(depth_map, config)

        # Check aspect ratio is preserved
        expected_height = config.model_width * (image.shape[0] / image.shape[1])
        assert abs(height_data.height_mm - expected_height) < 0.1

    def test_pipeline_handles_various_image_formats(self, tmp_path: Path):
        """Test that pipeline handles different image formats."""
        formats = [".jpg", ".png", ".bmp", ".tiff"]

        for fmt in formats:
            image_path = tmp_path / f"test_image{fmt}"
            image = np.random.randint(0, 255, (64, 64, 3), dtype=np.uint8)
            Image.fromarray(image).save(image_path)

            loader = ImageLoader()
            loaded = loader.load(image_path)

            assert loaded.shape == (64, 64, 3), f"Failed for format {fmt}"

    def test_converter_result_structure(self, sample_image_file: Path, tmp_path: Path):
        """Test that Converter returns properly structured result."""
        # Note: This test may be slow as it runs actual AI inference
        # Skip if model not available
        pytest.importorskip("transformers")

        output_path = tmp_path / "output.scad"
        converter = Converter()

        try:
            result = converter.convert(
                input_path=sample_image_file,
                output_path=output_path,
            )

            assert isinstance(result, ConversionResult)
            assert result.scad_code is not None
            assert len(result.scad_code) > 0
            assert result.scad_path == output_path
            assert result.processing_time > 0
            assert output_path.exists()

            # Verify file content matches result
            assert output_path.read_text() == result.scad_code

        finally:
            converter.release_model()

    def test_converter_progress_callback(self, sample_image_file: Path, tmp_path: Path):
        """Test that progress callback is called during conversion."""
        pytest.importorskip("transformers")

        progress_stages = []

        def progress_callback(stage: str, progress: float):
            progress_stages.append((stage, progress))

        output_path = tmp_path / "output.scad"
        converter = Converter()

        try:
            converter.convert(
                input_path=sample_image_file,
                output_path=output_path,
                progress_callback=progress_callback,
            )

            # Verify progress was reported
            assert len(progress_stages) > 0

            # Check that key stages were reported
            stage_names = [s[0] for s in progress_stages]
            assert "Loading image" in stage_names

        finally:
            converter.release_model()


class TestPipelineErrorHandling:
    """Test error handling across the pipeline."""

    def test_invalid_image_path(self):
        """Test that pipeline handles invalid image paths."""
        converter = Converter()

        with pytest.raises(FileNotFoundError):
            converter.convert(
                input_path=Path("/nonexistent/image.jpg"),
                output_path=Path("/tmp/output.scad"),
            )

    def test_invalid_image_format(self, tmp_path: Path):
        """Test that pipeline rejects invalid image formats."""
        from image_to_scad.exceptions import ImageLoadError

        invalid_file = tmp_path / "test.txt"
        invalid_file.write_text("This is not an image")

        loader = ImageLoader()

        with pytest.raises(ImageLoadError):
            loader.load(invalid_file)

    def test_corrupt_image_file(self, tmp_path: Path):
        """Test that pipeline handles corrupt image files."""
        from image_to_scad.exceptions import ImageLoadError

        corrupt_file = tmp_path / "corrupt.png"
        corrupt_file.write_bytes(b"PNG\x00\x00corrupt data")

        loader = ImageLoader()

        with pytest.raises(ImageLoadError):
            loader.load(corrupt_file)

    def test_empty_depth_map(self, default_config: ConversionConfig):
        """Test that pipeline handles edge cases in depth maps."""
        analyzer = DepthAnalyzer()

        # Uniform depth map (no variation)
        uniform_depth = np.ones((64, 64), dtype=np.float32) * 0.5
        height_data = analyzer.analyze(uniform_depth, default_config)

        # Should still produce valid output
        assert height_data.heights.shape == (64, 64)
        # All heights should be at base_thickness for uniform input
        assert np.allclose(height_data.heights, default_config.base_thickness, atol=0.1)
